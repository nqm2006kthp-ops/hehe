<!DOCTYPE html>
<html lang="vi">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Magic Christmas - Ultra Optimized</title>
Â  Â Â 
Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

Â  Â  <style>
Â  Â  Â  Â  body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
Â  Â  Â  Â  #canvas-container { width: 100%; height: 100vh; position: fixed; top: 0; left: 0; }
Â  Â  Â  Â  #ui-layer { position: absolute; bottom: 8vh; width: 100%; text-align: center; pointer-events: none; z-index: 100; padding: 0 20px; box-sizing: border-box; }
Â  Â  Â  Â  .guide { color: rgba(255, 255, 255, 0.7); font-size: clamp(10px, 2.5vw, 14px); margin-bottom: 15px; text-shadow: 0 2px 4px black; }
Â  Â  Â  Â  #btnStart { pointer-events: auto; cursor: pointer; background: linear-gradient(to bottom, #D32F2F, #8B0000); color: #FFF; border: 2px solid #FFD700; padding: clamp(12px, 3vw, 20px) clamp(35px, 10vw, 70px); border-radius: 50px; font-weight: 800; font-size: clamp(14px, 4vw, 20px); box-shadow: 0 0 30px rgba(255, 0, 0, 0.5); animation: pulse 1.5s infinite; }
Â  Â  Â  Â  #camera-preview { position: absolute; top: 15px; left: 15px; width: clamp(100px, 20vw, 220px); height: auto; border: 1.5px solid rgba(255,215,0,0.5); transform: scaleX(-1); border-radius: 12px; background: #000; }
Â  Â  Â  Â  .controls-wrapper { position: absolute; top: 15px; right: 15px; pointer-events: auto; display: flex; flex-direction: column; gap: 10px; z-index: 150; }
Â  Â  Â  Â  .upload-btn { background: rgba(0, 0, 0, 0.8); border: 1.2px solid #FFD700; color: #FFD700; padding: 8px 16px; cursor: pointer; font-size: clamp(10px, 2vw, 12px); border-radius: 8px; backdrop-filter: blur(8px); transition: 0.3s; }
Â  Â  Â  Â  @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.06); } 100% { transform: scale(1); } }
Â  Â  </style>
</head>
<body>
Â  Â  <div id="ui-layer">
Â  Â  Â  Â  <div class="guide">ğŸ– XÃ²e tay: Explode | ğŸ«¶ 2 tay chá»¥m (TrÃ¡i tim): Love | âœŠ Náº¯m tay: Tree | ğŸ¤ NhÃ©o tay: View Photo</div>
Â  Â  Â  Â  <button id="btnStart" onclick="startSystem()">START MAGIC</button>
Â  Â  </div>
Â  Â  <div class="controls-wrapper" id="controls" style="display:none">
Â  Â  Â  Â  <label class="upload-btn">ğŸ“ Chá»n ThÆ° Má»¥c áº¢nh <input type="file" id="folder-input" webkitdirectory directory multiple></label>
Â  Â  Â  Â  <label class="upload-btn">ğŸ–¼ï¸ Chá»n Láº» Nhiá»u áº¢nh <input type="file" id="file-input" multiple accept="image/*"></label>
Â  Â  </div>
Â  Â  <div id="canvas-container"></div>
Â  Â  <video class="input_video" style="display:none"></video>
Â  Â  <canvas id="camera-preview"></canvas>

Â  Â  <script>
Â  Â  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
Â  Â Â 
Â  Â  // ÄÃƒ GIáº¢M 20% Sá» LÆ¯á»¢NG Háº T
Â  Â  const CONFIG = {Â 
Â  Â  Â  Â  goldCount: isMobile ? 960 : 2000,Â 
Â  Â  Â  Â  redCount: isMobile ? 240 : 400,Â 
Â  Â  Â  Â  explodeRadius: 60, treeHeight: 70, treeBaseRadius: 35Â 
Â  Â  };

Â  Â  let scene, camera, renderer, state = 'TREE';
Â  Â  let groupGold, groupRed, photoMeshes = [], selectedIndex = 0;
Â  Â  let titleMesh, starMesh, loveMesh;
Â  Â  let bgMusic = new Audio("./audio.mp3"); bgMusic.loop = true;

Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  if (!camera || !renderer) return;
Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  });

Â  Â  function createDecorations() {
Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  canvas.width = 1024; canvas.height = 256;
Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  ctx.font = 'bold italic 90px "Times New Roman"';
Â  Â  Â  Â  ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
Â  Â  Â  Â  ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 30;
Â  Â  Â  Â  ctx.fillText("MERRY CHRISTMAS", 512, 130);
Â  Â  Â  Â  titleMesh = new THREE.Mesh(
Â  Â  Â  Â  Â  Â  new THREE.PlaneGeometry(60, 15),
Â  Â  Â  Â  Â  Â  new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending })
Â  Â  Â  Â  );
Â  Â  Â  Â  titleMesh.position.set(0, 50, 0);
Â  Â  Â  Â  scene.add(titleMesh);

Â  Â  Â  Â  const starCanvas = document.createElement('canvas');
Â  Â  Â  Â  starCanvas.width = 128; starCanvas.height = 128;
Â  Â  Â  Â  const sCtx = starCanvas.getContext('2d');
Â  Â  Â  Â  sCtx.clearRect(0, 0, 128, 128);
Â  Â  Â  Â  sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
Â  Â  Â  Â  sCtx.beginPath();
Â  Â  Â  Â  const cx = 64, cy = 64, outer = 50, inner = 20;
Â  Â  Â  Â  for(let i = 0; i < 5; i++){
Â  Â  Â  Â  Â  Â  sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
Â  Â  Â  Â  Â  Â  sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
Â  Â  Â  Â  }
Â  Â  Â  Â  sCtx.closePath(); sCtx.fill();
Â  Â  Â  Â  starMesh = new THREE.Mesh(
Â  Â  Â  Â  Â  Â  new THREE.PlaneGeometry(12, 12),
Â  Â  Â  Â  Â  Â  new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(starCanvas), transparent: true, alphaTest: 0.5 })
Â  Â  Â  Â  );
Â  Â  Â  Â  starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
Â  Â  Â  Â  scene.add(starMesh);

Â  Â  Â  Â  const lCanvas = document.createElement('canvas');
Â  Â  Â  Â  lCanvas.width = 1024; lCanvas.height = 256;
Â  Â  Â  Â  const lCtx = lCanvas.getContext('2d');
Â  Â  Â  Â  lCtx.font = 'bold 110px "Segoe UI"';
Â  Â  Â  Â  lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center';
Â  Â  Â  Â  lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40;
Â  Â  Â  Â  lCtx.fillText("I LOVE YOU â¤ï¸", 512, 130);
Â  Â  Â  Â  loveMesh = new THREE.Mesh(
Â  Â  Â  Â  Â  Â  new THREE.PlaneGeometry(70, 18),
Â  Â  Â  Â  Â  Â  new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(lCanvas), transparent: true, blending: THREE.AdditiveBlending })
Â  Â  Â  Â  );
Â  Â  Â  Â  loveMesh.position.set(0, 0, 20);
Â  Â  Â  Â  loveMesh.visible = false;
Â  Â  Â  Â  scene.add(loveMesh);
Â  Â  }

Â  Â  function createParticleGroup(color, count) {
Â  Â  Â  Â  const geo = new THREE.BufferGeometry();
Â  Â  Â  Â  const pos = new Float32Array(count * 3);
Â  Â  Â  Â  const treeT = new Float32Array(count * 3);
Â  Â  Â  Â  const explodeT = new Float32Array(count * 3);
Â  Â  Â  Â  const heartT = new Float32Array(count * 3);
Â  Â  Â  Â  for(let i=0; i<count; i++) {
Â  Â  Â  Â  Â  Â  const h = Math.random() * CONFIG.treeHeight;
Â  Â  Â  Â  Â  Â  const r = ((CONFIG.treeHeight - h) / CONFIG.treeHeight) * CONFIG.treeBaseRadius * Math.sqrt(Math.random());
Â  Â  Â  Â  Â  Â  const theta = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  treeT[i*3] = r * Math.cos(theta); treeT[i*3+1] = h - CONFIG.treeHeight/2; treeT[i*3+2] = r * Math.sin(theta);
Â  Â  Â  Â  Â  Â  const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
Â  Â  Â  Â  Â  Â  const phi = Math.acos(2 * Math.random() - 1);
Â  Â  Â  Â  Â  Â  const lam = 2 * Math.PI * Math.random();
Â  Â  Â  Â  Â  Â  explodeT[i*3] = rad * Math.sin(phi) * Math.cos(lam); explodeT[i*3+1] = rad * Math.sin(phi) * Math.sin(lam); explodeT[i*3+2] = rad * Math.cos(phi);
Â  Â  Â  Â  Â  Â  const t = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  let hx = 16 * Math.pow(Math.sin(t), 3); let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
Â  Â  Â  Â  Â  Â  const rFill = Math.pow(Math.random(), 0.5);
Â  Â  Â  Â  Â  Â  heartT[i*3] = hx * rFill * 2.2; heartT[i*3+1] = hy * rFill * 2.2; heartT[i*3+2] = (Math.random() - 0.5) * 10;
Â  Â  Â  Â  Â  Â  pos[i*3] = treeT[i*3]; pos[i*3+1] = treeT[i*3+1]; pos[i*3+2] = treeT[i*3+2];
Â  Â  Â  Â  }
Â  Â  Â  Â  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
Â  Â  Â  Â  geo.userData = { tree: treeT, explode: explodeT, heart: heartT };
Â  Â  Â  Â  return new THREE.Points(geo, new THREE.PointsMaterial({ color: color, size: isMobile ? 0.8 : 0.6, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
Â  Â  }

Â  Â  function addPhoto(texture) {
Â  Â  Â  Â  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
Â  Â  Â  Â  const border = new THREE.Mesh(new THREE.PlaneGeometry(10.8, 10.8), new THREE.MeshBasicMaterial({color: 0xFFD700}));
Â  Â  Â  Â  border.position.z = -0.05; mesh.add(border); mesh.visible = false; scene.add(mesh); photoMeshes.push(mesh);
Â  Â  }

Â  Â  function handleUpload(e) {
Â  Â  Â  Â  const files = e.target.files; const loader = new THREE.TextureLoader();
Â  Â  Â  Â  Array.from(files).forEach(file => {
Â  Â  Â  Â  Â  Â  if (!file.type.startsWith('image/')) return;
Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  reader.onload = (ev) => { loader.load(ev.target.result, (tex) => { tex.encoding = THREE.sRGBEncoding; addPhoto(tex); }); };
Â  Â  Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function init3D() {
Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
Â  Â  Â  Â  camera.position.z = 100;
Â  Â  Â  Â  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
Â  Â  Â  Â  renderer.outputEncoding = THREE.sRGBEncoding;
Â  Â  Â  Â  document.getElementById('canvas-container').appendChild(renderer.domElement);
Â  Â  Â  Â  groupGold = createParticleGroup(0xFFD700, CONFIG.goldCount);
Â  Â  Â  Â  groupRed = createParticleGroup(0xFF0000, CONFIG.redCount);
Â  Â  Â  Â  scene.add(groupGold, groupRed);
Â  Â  Â  Â  createDecorations();
Â  Â  Â  Â  animate();
Â  Â  }

Â  Â  function animate() {
Â  Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  Â  const time = Date.now() * 0.001;
Â  Â  Â  Â  [groupGold, groupRed].forEach(g => {
Â  Â  Â  Â  Â  Â  const p = g.geometry.attributes.position.array;
Â  Â  Â  Â  Â  Â  let target = g.geometry.userData.tree;
Â  Â  Â  Â  Â  Â  if (state === 'HEART') target = g.geometry.userData.heart;
Â  Â  Â  Â  Â  Â  else if (state === 'EXPLODE' || state === 'PHOTO') target = g.geometry.userData.explode;
Â  Â  Â  Â  Â  Â  for(let i=0; i<p.length; i++) p[i] += (target[i] - p[i]) * 0.08;
Â  Â  Â  Â  Â  Â  g.geometry.attributes.position.needsUpdate = true;
Â  Â  Â  Â  Â  Â  if (state === 'HEART') { g.rotation.y *= 0.9; const s = 1 + Math.abs(Math.sin(time*3)) * 0.1; g.scale.set(s,s,s); }Â 
Â  Â  Â  Â  Â  Â  else {Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ÄÃƒ TÄ‚NG Tá»C Äá»˜ XOAY 20%
Â  Â  Â  Â  Â  Â  Â  Â  g.rotation.y += 0.006;Â 
Â  Â  Â  Â  Â  Â  Â  Â  g.scale.set(1,1,1);Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  if(titleMesh) titleMesh.visible = (state === 'TREE');
Â  Â  Â  Â  if(starMesh) starMesh.visible = (state === 'TREE');
Â  Â  Â  Â  if(loveMesh) {
Â  Â  Â  Â  Â  Â  loveMesh.visible = (state === 'HEART');
Â  Â  Â  Â  Â  Â  if(loveMesh.visible) { const s = 1 + Math.abs(Math.sin(time*3)) * 0.15; loveMesh.scale.set(s, s, 1); }
Â  Â  Â  Â  }

Â  Â  Â  Â  photoMeshes.forEach((mesh, i) => {
Â  Â  Â  Â  Â  Â  if (state === 'EXPLODE') {
Â  Â  Â  Â  Â  Â  Â  Â  mesh.visible = true;
Â  Â  Â  Â  Â  Â  Â  Â  const angle = groupGold.rotation.y + (i * (Math.PI * 2 / photoMeshes.length));
Â  Â  Â  Â  Â  Â  Â  Â  mesh.position.lerp(new THREE.Vector3(Math.sin(angle)*35, Math.sin(time+i)*5, Math.cos(angle)*35), 0.1);
Â  Â  Â  Â  Â  Â  Â  Â  mesh.lookAt(camera.position); mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.cos(angle)*35 > 25) selectedIndex = i;
Â  Â  Â  Â  Â  Â  } else if (state === 'PHOTO' && i === selectedIndex) {
Â  Â  Â  Â  Â  Â  Â  Â  mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1); mesh.scale.lerp(new THREE.Vector3(4, 4, 4), 0.1); mesh.lookAt(camera.position);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1); if(mesh.scale.x < 0.01) mesh.visible = false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  renderer.render(scene, camera);
Â  Â  }

Â  Â  async function startSystem() {
Â  Â  Â  Â  document.getElementById('btnStart').style.display = 'none';
Â  Â  Â  Â  document.getElementById('controls').style.display = 'flex';
Â  Â  Â  Â  bgMusic.play().catch(() => {});
Â  Â  Â  Â  init3D();
Â  Â  Â  Â  const video = document.getElementsByClassName('input_video')[0];
Â  Â  Â  Â  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
Â  Â  Â  Â Â 
Â  Â  Â  Â  // TÄ‚NG Äá»˜ CHÃNH XÃC AI Äá»‚ TRÃNH KHUÃ”N Máº¶T
Â  Â  Â  Â  hands.setOptions({Â 
Â  Â  Â  Â  Â  Â  maxNumHands: 2,Â 
Â  Â  Â  Â  Â  Â  modelComplexity: 1,Â 
Â  Â  Â  Â  Â  Â  minDetectionConfidence: 0.8, // TÄƒng tá»« 0.5 lÃªn 0.8
Â  Â  Â  Â  Â  Â  minTrackingConfidence: 0.7Â 
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  hands.onResults(results => {
Â  Â  Â  Â  Â  Â  const cv = document.getElementById('camera-preview');
Â  Â  Â  Â  Â  Â  const ctx = cv.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.clearRect(0,0,cv.width, cv.height);
Â  Â  Â  Â  Â  Â  ctx.drawImage(results.image, 0, 0, cv.width, cv.height);

Â  Â  Â  Â  Â  Â  if (results.multiHandLandmarks.length === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  // KIá»‚M TRA HÃŒNH TRÃI TIM THá»°C Sá»°
Â  Â  Â  Â  Â  Â  Â  Â  const h1 = results.multiHandLandmarks[0];
Â  Â  Â  Â  Â  Â  Â  Â  const h2 = results.multiHandLandmarks[1];
Â  Â  Â  Â  Â  Â  Â  Â  const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
Â  Â  Â  Â  Â  Â  Â  Â  const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Chá»‰ hiá»‡n HEART náº¿u 2 tay chá»¥m láº¡i (ngÃ³n trá» gáº§n nhau vÃ  ngÃ³n cÃ¡i gáº§n nhau)
Â  Â  Â  Â  Â  Â  Â  Â  if (distIndex < 0.2 && distThumb < 0.2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state = 'HEART';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state = 'EXPLODE'; // Náº¿u 2 tay nhÆ°ng khÃ´ng chá»¥m thÃ¬ coi nhÆ° xÃ²e tay
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (results.multiHandLandmarks.length === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  const lm = results.multiHandLandmarks[0];
Â  Â  Â  Â  Â  Â  Â  Â  const openDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
Â  Â  Â  Â  Â  Â  Â  Â  const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Tá»I Æ¯U PINCH: NgÆ°á»¡ng pinchDist < 0.07 Ä‘á»ƒ dá»… thá»±c hiá»‡n hÆ¡n
Â  Â  Â  Â  Â  Â  Â  Â  if (pinchDist < 0.07) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state = 'PHOTO';
Â  Â  Â  Â  Â  Â  Â  Â  } else if (openDist > 0.35) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state = 'EXPLODE';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state = 'TREE';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  state = 'TREE';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  const cam = new Camera(video, {Â 
Â  Â  Â  Â  Â  Â  onFrame: async () => { await hands.send({image: video}); },
Â  Â  Â  Â  Â  Â  width: isMobile ? 480 : 1280,
Â  Â  Â  Â  Â  Â  height: isMobile ? 640 : 720
Â  Â  Â  Â  });
Â  Â  Â  Â  cam.start();
Â  Â  }

Â  Â  document.getElementById('file-input').addEventListener('change', handleUpload);
Â  Â  document.getElementById('folder-input').addEventListener('change', handleUpload);
</script>
</body>
</html>
hÃ£y sá»­a láº¡i code nÃ y, thao tÃ¡c tay hÃ¬nh trÃ¡i tim khÃ´ng thá»±c hiá»‡n Ä‘Æ°á»£c vÃ  Ã¢m thanh khÃ´ng hoáº¡t Ä‘á»™ng
