<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Final Pro Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #canvas-container { width: 100%; height: 100vh; position: fixed; top: 0; left: 0; }
        #ui-layer { position: absolute; bottom: 8vh; width: 100%; text-align: center; pointer-events: none; z-index: 100; padding: 0 20px; box-sizing: border-box; }
        .guide { color: rgba(255, 255, 255, 0.7); font-size: clamp(10px, 2.5vw, 14px); margin-bottom: 15px; text-shadow: 0 2px 4px black; }
        #btnStart { pointer-events: auto; cursor: pointer; background: linear-gradient(to bottom, #D32F2F, #8B0000); color: #FFF; border: 2px solid #FFD700; padding: clamp(12px, 3vw, 20px) clamp(35px, 10vw, 70px); border-radius: 50px; font-weight: 800; font-size: clamp(14px, 4vw, 20px); box-shadow: 0 0 30px rgba(255, 0, 0, 0.5); animation: pulse 1.5s infinite; }
        #camera-preview { position: absolute; top: 15px; left: 15px; width: clamp(100px, 20vw, 220px); height: auto; border: 1.5px solid rgba(255,215,0,0.5); transform: scaleX(-1); border-radius: 12px; background: #000; }
        .controls-wrapper { position: absolute; top: 15px; right: 15px; pointer-events: auto; display: flex; flex-direction: column; gap: 10px; z-index: 150; }
        .upload-btn { background: rgba(0, 0, 0, 0.8); border: 1.2px solid #FFD700; color: #FFD700; padding: 8px 16px; cursor: pointer; font-size: clamp(10px, 2vw, 12px); border-radius: 8px; backdrop-filter: blur(8px); transition: 0.3s; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.06); } 100% { transform: scale(1); } }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="guide">üñê X√≤e tay: Xoay ·∫£nh | ü´∂ 2 tay ch·ª•m: Love | ‚úä N·∫Øm tay: C√¢y th√¥ng | ü§è Nh√©o tay: Xem ·∫£nh</div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>
    <div class="controls-wrapper" id="controls" style="display:none">
        <label class="upload-btn">üìÅ Ch·ªçn Th∆∞ M·ª•c ·∫¢nh <input type="file" id="folder-input" webkitdirectory directory multiple></label>
        <label class="upload-btn">üñºÔ∏è Ch·ªçn L·∫ª Nhi·ªÅu ·∫¢nh <input type="file" id="file-input" multiple accept="image/*"></label>
    </div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const CONFIG = { goldCount: isMobile?800:1600, redCount: isMobile?200:320, explodeRadius: 65, treeHeight: 75, treeBaseRadius: 38 };
    let scene, camera, renderer, state = 'TREE';
    let groupGold, groupRed, photoMeshes = [], selectedIndex = 0;
    let titleMesh, starMesh, loveMesh;
    let bgMusic = new Audio("./audio.mp3"); bgMusic.loop = true;

    let wakeLock = null; let idleTimer = null; const IDLE_TIME_LIMIT = 30000;
    async function requestWakeLock() { if ('wakeLock' in navigator && !wakeLock) { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} } }
    function releaseWakeLock() { if (wakeLock) { wakeLock.release().then(() => { wakeLock = null; }); } }
    function resetEnergyTimer(isActive) { if (isActive) { requestWakeLock(); if (idleTimer) clearTimeout(idleTimer); idleTimer = setTimeout(() => releaseWakeLock(), IDLE_TIME_LIMIT); } }

    window.addEventListener('resize', () => { if (!camera || !renderer) return; camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    function createDecorations() {
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 256;
        const ctx = canvas.getContext('2d'); ctx.font = 'bold italic 90px "Times New Roman"'; ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center'; ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 30; ctx.fillText("MERRY CHRISTMAS", 512, 130);
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending }));
        titleMesh.position.set(0, 55, 0); scene.add(titleMesh);

        const starCanvas = document.createElement('canvas'); starCanvas.width = 128; starCanvas.height = 128;
        const sCtx = starCanvas.getContext('2d'); sCtx.clearRect(0,0,128,128); sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
        sCtx.beginPath(); const cx=64, cy=64, out=55, inn=25;
        for(let i=0; i<5; i++){ sCtx.lineTo(cx+Math.cos((18+i*72)/180*Math.PI)*out, cy-Math.sin((18+i*72)/180*Math.PI)*out); sCtx.lineTo(cx+Math.cos((54+i*72)/180*Math.PI)*inn, cy-Math.sin((54+i*72)/180*Math.PI)*inn); }
        sCtx.closePath(); sCtx.fill();
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(starCanvas), transparent: true, alphaTest: 0.5 }));
        starMesh.position.set(0, CONFIG.treeHeight/2 + 3, 0); scene.add(starMesh);

        const lCanvas = document.createElement('canvas'); lCanvas.width = 1024; lCanvas.height = 256;
        const lCtx = lCanvas.getContext('2d'); lCtx.font = 'bold 110px "Segoe UI"'; lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center'; lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40; lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);
        loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(lCanvas), transparent: true, blending: THREE.AdditiveBlending }));
        loveMesh.position.set(0, 0, 25); loveMesh.visible = false; scene.add(loveMesh);
    }

    function createParticleGroup(color, count) {
        const geo = new THREE.BufferGeometry(); const pos = new Float32Array(count * 3); const treeT = new Float32Array(count * 3); const explodeT = new Float32Array(count * 3); const heartT = new Float32Array(count * 3);
        for(let i=0; i<count; i++) {
            const h = Math.random()*CONFIG.treeHeight; const r = ((CONFIG.treeHeight-h)/CONFIG.treeHeight)*CONFIG.treeBaseRadius*Math.sqrt(Math.random()); const theta = Math.random()*Math.PI*2;
            treeT[i*3] = r*Math.cos(theta); treeT[i*3+1] = h-CONFIG.treeHeight/2; treeT[i*3+2] = r*Math.sin(theta);
            const rad = CONFIG.explodeRadius*Math.cbrt(Math.random()); const phi = Math.acos(2*Math.random()-1); const lam = 2*Math.PI*Math.random();
            explodeT[i*3] = rad*Math.sin(phi)*Math.cos(lam); explodeT[i*3+1] = rad*Math.sin(phi)*Math.sin(lam); explodeT[i*3+2] = rad*Math.cos(phi);
            const t = Math.random()*Math.PI*2; let hx = 16*Math.pow(Math.sin(t), 3); let hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); const rF = Math.pow(Math.random(), 0.5);
            heartT[i*3] = hx*rF*2.5; heartT[i*3+1] = hy*rF*2.5; heartT[i*3+2] = (Math.random()-0.5)*15;
            pos[i*3] = treeT[i*3]; pos[i*3+1] = treeT[i*3+1]; pos[i*3+2] = treeT[i*3+2];
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geo.userData = { tree: treeT, explode: explodeT, heart: heartT };
        return new THREE.Points(geo, new THREE.PointsMaterial({ color: color, size: isMobile?0.9:0.7, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
    }

    function addPhoto(texture) {
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
        const border = new THREE.Mesh(new THREE.PlaneGeometry(10.8, 10.8), new THREE.MeshBasicMaterial({color: 0xFFD700})); border.position.z = -0.05; mesh.add(border); mesh.visible = false; scene.add(mesh); photoMeshes.push(mesh);
    }

    function handleUpload(e) {
        const files = e.target.files; const loader = new THREE.TextureLoader();
        Array.from(files).forEach(file => { if (!file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (ev) => { loader.load(ev.target.result, (tex) => { tex.encoding = THREE.sRGBEncoding; addPhoto(tex); }); }; reader.readAsDataURL(file); });
    }

    function init3D() {
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.z = 100;
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        groupGold = createParticleGroup(0xFFD700, CONFIG.goldCount); groupRed = createParticleGroup(0xFF0000, CONFIG.redCount); scene.add(groupGold, groupRed);
        createDecorations(); animate();
    }

    function animate() {
        requestAnimationFrame(animate); const time = Date.now()*0.001;
        [groupGold, groupRed].forEach(g => {
            const p = g.geometry.attributes.position.array; let target = g.geometry.userData.tree;
            if (state === 'HEART') target = g.geometry.userData.heart; else if (state === 'EXPLODE' || state === 'PHOTO') target = g.geometry.userData.explode;
            for(let i=0; i<p.length; i++) p[i] += (target[i] - p[i])*0.1;
            g.geometry.attributes.position.needsUpdate = true;
            if (state === 'HEART') { g.rotation.y *= 0.9; const s = 1 + Math.abs(Math.sin(time*4))*0.12; g.scale.set(s,s,s); } else { g.rotation.y += 0.006; g.scale.set(1,1,1); }
        });
        if(titleMesh) titleMesh.visible = (state === 'TREE');
        if(starMesh) starMesh.visible = (state === 'TREE');
        if(loveMesh) { loveMesh.visible = (state === 'HEART'); if(loveMesh.visible) { const s = 1 + Math.abs(Math.sin(time*4))*0.18; loveMesh.scale.set(s, s, 1); } }
        photoMeshes.forEach((mesh, i) => {
            if (state === 'EXPLODE') {
                mesh.visible = true; const angle = groupGold.rotation.y + (i * (Math.PI * 2 / photoMeshes.length));
                mesh.position.lerp(new THREE.Vector3(Math.sin(angle)*35, Math.sin(time+i)*5, Math.cos(angle)*35), 0.12);
                mesh.lookAt(camera.position); mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                if (Math.cos(angle)*35 > 25) selectedIndex = i;
            } else if (state === 'PHOTO' && i === selectedIndex) {
                mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.12); mesh.scale.lerp(new THREE.Vector3(4, 4, 4), 0.12); mesh.lookAt(camera.position);
            } else { mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.15); if(mesh.scale.x < 0.01) mesh.visible = false; }
        });
        renderer.render(scene, camera);
    }

    async function startSystem() {
        document.getElementById('btnStart').style.display = 'none'; document.getElementById('controls').style.display = 'flex';
        bgMusic.load(); bgMusic.play().catch(e => console.log("C·∫ßn t∆∞∆°ng t√°c"));
        init3D();
        const video = document.getElementsByClassName('input_video')[0];
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.85, minTrackingConfidence: 0.8 });
        hands.onResults(results => {
            const cv = document.getElementById('camera-preview'); const ctx = cv.getContext('2d'); ctx.clearRect(0,0,cv.width, cv.height); ctx.drawImage(results.image, 0, 0, cv.width, cv.height);
            let active = false;
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0]; const h2 = results.multiHandLandmarks[1];
                const dIdx = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y); const dThm = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                if (dIdx < 0.15 && dThm < 0.15) { state = 'HEART'; active = true; } else { state = 'EXPLODE'; active = true; }
            } else if (results.multiHandLandmarks.length === 1) {
                const lm = results.multiHandLandmarks[0]; const openD = Math.hypot(lm[8].x-lm[0].x, lm[8].y-lm[0].y); const pinchD = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                if (pinchD < 0.08) { state = 'PHOTO'; active = true; } else if (openD > 0.38) { state = 'EXPLODE'; active = true; } else state = 'TREE';
            } else { state = 'TREE'; }
            resetEnergyTimer(active);
        });
        const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 1280, height: 720 });
        cam.start();
    }
    document.getElementById('file-input').addEventListener('change', handleUpload);
    document.getElementById('folder-input').addEventListener('change', handleUpload);
    document.addEventListener('visibilitychange', async () => { if (wakeLock !== null && document.visibilityState === 'visible') { await requestWakeLock(); } });
    </script>
</body>
</html>